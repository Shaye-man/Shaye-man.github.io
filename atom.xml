<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>『搬砖少年』</title>
  
  <subtitle>不搬砖，何以致富！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shaye-man.github.io/"/>
  <updated>2019-01-16T08:28:31.669Z</updated>
  <id>https://shaye-man.github.io/</id>
  
  <author>
    <name>江双耀</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>先验概率、后验概率、贝叶斯、似然函数、极大似然估计</title>
    <link href="https://shaye-man.github.io/2019/01/16/byaes-theor/"/>
    <id>https://shaye-man.github.io/2019/01/16/byaes-theor/</id>
    <published>2019-01-16T07:56:35.000Z</published>
    <updated>2019-01-16T08:28:31.669Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">在机器学习的过程当中，经常会出现先验概率、后验概率、贝叶斯、似然函数、极大似然估计这几个概念，如果不对他们理解透彻的话，对后续的学习影响很大。</blockquote><a id="more"></a><h2 id="先验概率">先验概率</h2><blockquote><p><strong>是指根据以往经验和分析得到的概率.</strong> 意思是说我们人有一个常识,比如骰子,我们都知道概率是1/6,而且无数次重复实验表明是这个数,这是一种我们人的常识,也是我们在不知道任何情况下必然会说出的一个值.而所谓的先验概率是我们人在未知条件下对事件发生可能性猜测的数学表示!</p></blockquote><p>公式表达如下： <span class="math display">\[P(θ)\]</span></p><h2 id="后验概率">后验概率</h2><blockquote><p>一个事件在另一个事件发生条件下的条件概率</p></blockquote><p>公式表达如下： <span class="math display">\[P(θ|x)\]</span></p><h2 id="贝叶斯公式">贝叶斯公式</h2><blockquote><p>表现了后验概率与先验概率的关系</p></blockquote><p>公式表达如下： <span class="math display">\[P(θ|x) = \frac{P(x|θ) P(θ)}{P(x)} \]</span></p><h2 id="似然函数">似然函数</h2><blockquote><p>关注的量不再是事件的发生概率，而是已知发生了某些事件，我们希望知道参数应该是多少。 假设我们抛了两次硬币，并且知道了结果是两次头朝上，这时候，我希望知道这枚硬币抛出去正面朝上的概率为0.5的概率是多少？正面朝上的概率为0.8的概率是多少？ 如果我们希望知道正面朝上概率为0.5的概率，这个东西就叫做似然函数，可以说成是对某一个参数的猜想（p=0.5）的概率.</p></blockquote><p>公式表达如下： <span class="math display">\[P(x|θ) \]</span></p><h2 id="极大似然估计">极大似然估计</h2><blockquote><p>最大似然估计，就是在已知观测的数据的前提下，找到使得似然概率最大的参数值。</p></blockquote><h2 id="举例说明它们之间的关系">举例说明它们之间的关系</h2><p>如果用阴天预测明天是否会下雨</p><p><strong>先验概率：</strong> 下雨的概率 <span class="math display">\[P(rain)\]</span></p><p><strong>后验概率：</strong> 已经知道阴天，下雨的概率： <span class="math display">\[P(rain|cloudy)\]</span></p><p><strong>贝叶斯公式：</strong> 表现了后验概率与先验概率的关系: <span class="math display">\[P(rain|cloudy) = \frac{P(cloudy|rain) P(rain)}{P(cloudy)} \]</span></p><ul><li><p>把注意力集中在分子，公式可以理解为：阴天会下雨的概率（后验概率），不仅跟下雨那天的确是阴天的概率（条件概率）有关，还跟下雨本身的概率（先验概率）有关，如果下雨本身概率很低（先验概率=0），即便下雨一定阴天（条件概率=1），那么下雨的概率还是会很低（后验概率=0） <span class="math display">\[P(rain|cloudy) = \frac{P(cloudy|rain) P(rain)}{P(cloudy)} \]</span></p></li><li><p>把注意力集中在分母，公式可以理解为：阴天会下雨的概率（后验概率），不仅跟下雨并且是阴天的概率有关，还跟不下雨也是阴天的概率有关 <span class="math display">\[P(rain|cloudy) = \frac{P(cloudy|rain) P(rain)}{P(cloudy|rain)P(rain)+P(cloudy|norain)P(norain)} \]</span></p></li></ul><p><strong>似然函数：</strong> 根据贝叶斯公式得出的先验概率与后验概率的关系参数 <span class="math display">\[P(cloudy|rain)\]</span></p><p>由于已经知道是阴天了，忽略P(cloudy) <span class="math display">\[P(rain|cloudy)∝P(cloudy|rain) P(rain) \]</span></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;在机器学习的过程当中，经常会出现先验概率、后验概率、贝叶斯、似然函数、极大似然估计这几个概念，如果不对他们理解透彻的话，对后续的学习影响很大。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://shaye-man.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数学知识" scheme="https://shaye-man.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="机器学习" scheme="https://shaye-man.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数学知识" scheme="https://shaye-man.github.io/tags/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>深入解读重写equals()和hashcode()</title>
    <link href="https://shaye-man.github.io/2019/01/14/equals/"/>
    <id>https://shaye-man.github.io/2019/01/14/equals/</id>
    <published>2019-01-14T13:47:21.000Z</published>
    <updated>2019-01-16T07:52:06.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要重写equals">为什么要重写equals( )</h2><p>判断两个对象在逻辑上是否相等，如根据类的成员变量来判断两个类的实例是否相等，而继承Object中的equals方法只能判断两个引用变量是否是同一个对象，这样我们往往需要重写equals()方法。 我们在向一个没有重复对象的集合中添加元素时，集合中存放的往往是对象，我们需要先判断集合中是否存在已知对象，这样就必须重写equals( ) <a id="more"></a> ## 怎样重写equals( ) 重写equals( )必须遵循的要求如下：</p><ul><li><strong>自反性:</strong> 对于任何非空引用x，x.equals(x)应该返回true。</li><li><strong>对称性:</strong> 对于任何引用x和y，如果x.equals(y)返回true，那么y.equals(x)也应该返回true。</li><li><strong>传递性:</strong> 对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。</li><li><strong>一致性:</strong> 如果x和y引用的对象没有发生变化，那么反复调用x.equals(y)应该返回同样的结果。</li><li><strong>非空性:</strong> 对于任意非空引用x，x.equals(null)应该返回false。</li></ul><h3 id="自反性原则">自反性原则</h3><blockquote><p>在JavaBean中，经常会覆写equals方法，从而根据实际业务情况来判断两个对象是否相等，比如我们写一个person类，根据姓名来判断两个person类实例对象是否相等。代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person person= (Person) obj;</span><br><span class="line">            <span class="keyword">return</span> name.equalsIgnoreCase(person.getName().trim());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p1=<span class="keyword">new</span> Person(<span class="string">"张三"</span>);</span><br><span class="line">        Person p2=<span class="keyword">new</span> Person(<span class="string">"张三    "</span>);</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        list.add(p1);</span><br><span class="line">        list.add(p2);</span><br><span class="line">        System.out.println(<span class="string">"是否包含张三："</span>+list.contains(p1)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">"是否包含张三："</span>+list.contains(p2)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list中均含有这个两个生成的person对象，结果应该都为true，但是实际结果：</p><ul><li>是否包含张三：true</li><li>是否包含张三：false</li></ul><p><strong>第二个为什么会是false呢？</strong></p><blockquote><p>原因在于list中检查是否含有元素时是通过调用对象的equals方法来判断的，也就是说 contains（p2）传递进去会依次执行p2.equals(p1)、p2.equals(p2)，只要一个返回true，结果就是true。但是这里p2.equals(p2)返回的是false？由于我们对字符前后进行了空格的切割造成p2.equals(p2)的比较实际上是：“张三 ”.equals（“张三”），一个有空格，一个没有空格就出错了。</p></blockquote><p>这个违背了equals的自反性原则：对于任何非空引用x，x.equals(x)应该返回true。</p><p>这里只要去掉trim方法就可以解决。</p><h3 id="对称性和非空性原则">对称性和非空性原则</h3><p>上面这个例子，还并不是很好，如果我们传入null值，会怎么样呢？ <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p2=<span class="keyword">new</span> Person(<span class="keyword">null</span>);<span class="comment">//往对象传入空值</span></span><br><span class="line"></span><br><span class="line">是否包含张三：<span class="keyword">true</span> <span class="comment">//输出结果</span></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NullPointerException</span><br></pre></td></tr></table></figure></p><p><strong>为什么会返回true且报空指针？</strong> 原因在执行p2.equals(p1)时，由于p2的name是一个null值，所以调用name.equalsIgnoreCase()方法时就会报空指针异常。</p><p>这是在覆写equals方法时没有遵循对称性原则：对于任何应用x,y的情形，如果想x.equals(y)返回true，那么y.equals(x),也应该返回true。</p><p>应该在equals方法里加上是否为null值的判断： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person person= (Person) obj;</span><br><span class="line">            <span class="keyword">if</span> (person.getName() == <span class="keyword">null</span> || name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name.equalsIgnoreCase(person.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="传递性原则">传递性原则</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假设现在我们有一个Employee类继承自person类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Employee)&#123;</span><br><span class="line">            Employee e = (Employee)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj) &amp;&amp; e.getId() == id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Employee e1=<span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">12</span>);</span><br><span class="line">        Employee e2=<span class="keyword">new</span> Employee(<span class="string">"张三"</span>,<span class="number">123</span>);</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>);</span><br><span class="line">  </span><br><span class="line">        System.out.println(p1.equals(e1)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(p1.equals(e2)); <span class="comment">//true</span></span><br><span class="line">        System.out.println(e1.equals(e2)); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在name和ID都相同的情况下才是同一个员工，避免同名同姓的。在main里定义了，两个员工和一个社会闲杂人员，虽然同名同姓但肯定不是同一个人。运行结果应该三个都是false才对。但是输出结果为：<strong><em>true；true；false;</em></strong></p><p>p1尽然等于e1,也等于e2，不是同一个类的实例也相等了？因为p1.equals(e1)是调用父类的equals方法进行判断的它使用instanceof关键字检查e1是否是person的实例，由于employee和person是继承关系，结果就是true了。但是放过来就不成立，e1,e2就不等于p1，这也是违反对称性原则的一个典型案例。</p><p>e1竟然不等于e2？e1.equals(e2)调用的是Employee的equals方法，不仅要判断姓名相同还有判断工号相同，两者的工号不同，不相等时对的。但是p1等于e1,也等于e2，e1却不等于e2，这里就存在矛盾，等式不传递是因为违反了equals的传递性原则：对于实例对象x、y、z；如果x.equals(y)返回true，y.equals(z)返回true，那么x.equals(z)也应该返回true。</p><p>上述情况会发生是因为父类使用instanceof关键字(是否是这个特定类或者是它的子类的一个实例)，用来判断是否是一个类的实例对象的，这很容易让子类“钻空子”。想要解决也很简单，使用getClass进行类型的判断，person类的equals方法修改如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; obj.getClass() == <span class="keyword">this</span>.getClass()) &#123;</span><br><span class="line">            Person person= (Person) obj;</span><br><span class="line">            <span class="keyword">if</span> (person.getName() == <span class="keyword">null</span> || name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name.equalsIgnoreCase(person.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="重写equals-必须重写hashcode">重写equals( )必须重写hashcode( )</h3><p>理由参考如下板块 <strong>↓↓↓</strong></p><h2 id="为什么要重写hashcode">为什么要重写hashcode( )</h2><ul><li><p>用以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。如下： (1)当obj1.equals(obj2)为true时，obj1.hashCode() == obj2.hashCode()必须为true</p>(2)当obj1.hashCode() == obj2.hashCode()为false时，obj1.equals(obj2)必须为false</li><li><p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p></li></ul><h2 id="为什么两个对象有相同的hashcode值它们也不一定是相等">为什么两个对象有相同的hashcode值，它们也不一定是相等？</h2><p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。</p><p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。 ## 怎样重写hashcode( ) ### 重写hashcode( )的原则</p><ol type="1"><li>同一个对象多次调用hashCode()方法应该返回相同的值；</li><li>当两个对象通过equals()方法比较返回true时，这两个对象的hashCode()应该返回相等的（int）值；</li><li>对象中用作equals()方法比较标准的Filed(成员变量（类属性）)，都应该用来计算hashCode值。</li></ol><h3 id="计算hashcode值的方法">计算hashCode值的方法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//f是Filed属性</span></span><br><span class="line"><span class="keyword">boolean</span>    hashCode=(f?<span class="number">0</span>:<span class="number">1</span>)</span><br><span class="line">(<span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>,<span class="keyword">int</span>)      hashCode=(<span class="keyword">int</span>)f</span><br><span class="line"><span class="keyword">long</span>       hashCode=(<span class="keyword">int</span>)(f^(f&gt;&gt;&gt;<span class="number">32</span>))</span><br><span class="line"><span class="keyword">float</span>       hashCode=Float.floatToIntBits(f)</span><br><span class="line"><span class="keyword">double</span>   hashCode=(<span class="keyword">int</span>)(<span class="number">1</span>^(<span class="number">1</span>&gt;&gt;&gt;<span class="number">32</span>))</span><br><span class="line">普通引用类型    hashCode=f.hashCode()</span><br></pre></td></tr></table></figure><p>将计算出的每个Filed的hashCode值相加返回，为了避免直接相加产生的偶然相等（单个不相等，加起来就相等了），为每个Filed乘以一个质数后再相加，例如有： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>  f1.hashCode()*<span class="number">17</span>+(<span class="keyword">int</span>)f2.13</span><br></pre></td></tr></table></figure></p><h3 id="常用示例">常用示例</h3><p>1.经典示例，这种17和31散列码的想法来自经典的Java书籍——《Effective Java》第九条。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String passport;</span><br><span class="line">    <span class="comment">//getters and setters, constructor</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> User)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="keyword">return</span> user.name.equals(name) &amp;&amp;</span><br><span class="line">                user.age == age &amp;&amp;</span><br><span class="line">                user.passport.equals(passport);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Idea from effective Java : Item 9</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + name.hashCode();</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        result = <span class="number">31</span> * result + passport.hashCode();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.对于JDK7及更新版本，你可以是使用java.util.Objects 来重写 equals 和 hashCode 方法，代码如下 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String passport;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//getters and setters, constructor</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> User)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        User user = (User) o;</span><br><span class="line">        <span class="keyword">return</span> age == user.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, user.name) &amp;&amp;</span><br><span class="line">                Objects.equals(passport, user.passport);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age, passport);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要重写equals&quot;&gt;为什么要重写equals( )&lt;/h2&gt;
&lt;p&gt;判断两个对象在逻辑上是否相等，如根据类的成员变量来判断两个类的实例是否相等，而继承Object中的equals方法只能判断两个引用变量是否是同一个对象，这样我们往往需要重写equals()方法。 我们在向一个没有重复对象的集合中添加元素时，集合中存放的往往是对象，我们需要先判断集合中是否存在已知对象，这样就必须重写equals( )
    
    </summary>
    
      <category term="JAVA" scheme="https://shaye-man.github.io/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="https://shaye-man.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>K近邻算法</title>
    <link href="https://shaye-man.github.io/2019/01/14/knn/"/>
    <id>https://shaye-man.github.io/2019/01/14/knn/</id>
    <published>2019-01-14T06:22:18.000Z</published>
    <updated>2019-01-16T07:58:08.528Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">k近邻法是一种基本分类与回归方法。但个人并不把它列入到机器学习中的学习算法，它本身并没有对数据进行理论建模的过程，而是根据现有的数据在n维空间的分布，来确定预测点的归属。这就好比，在现实世界的维度中，经常游走于男厕所的我们归为男性，而经常在女厕所出没的人我们归为女性或者是变态。</blockquote><a id="more"></a><h2 id="算法思想总结">算法思想总结</h2><blockquote><p>在训练集中数据和标签已知的情况下，输入测试数据，将测试数据的特征与训练集中对应的特征进行相互比较，找到训练集中与之最为相似的前K个数据，则该测试数据对应的类别就是K个数据中出现次数最多的那个分类，其算法的描述为：</p></blockquote><ol type="1"><li>计算测试数据与各个训练数据之间的距离；</li><li>按照距离的递增关系进行排序；</li><li>选取距离最小的K个点；</li><li>确定前K个点所在类别的出现频率；</li><li>返回前K个点中出现频率最高的类别作为测试数据的预测分类；</li></ol><h2 id="所使用数学公式介绍">所使用数学公式介绍</h2><h3 id="欧式距离">欧式距离</h3><p>计算空间中两点（x,y）的距离 <span class="math display">\[\begin{align}    d(x,y)= \sqrt{\sum_{k=1}^n(x_{k}-y_{k})^2}\end{align}\]</span></p><h3 id="min-max标准化">Min-Max标准化</h3><p>也称为离差标准化，是对原始数据的线性变换，使得结果映射到0-1之间 <span class="math display">\[\begin{align}    Value= \frac{X - Min} {X - Max}\end{align}\]</span> 如果想要将数据映射到(-1,1)，则将公式换成: <span class="math display">\[\begin{align}    Value= \frac{X - Mean} {X - Max}\end{align}\]</span></p><h3 id="均方根误差">均方根误差</h3><p>衡量观测值与真实值之间的偏差 <span class="math display">\[\begin{align}    RMSE= \sqrt\frac{\sum_{k=1}^n(Actual_{k}-Predicted_{k})^2}{n}\end{align}\]</span></p><h2 id="算法优点">算法优点</h2><ul><li>简单好用，容易理解，精度高，理论成熟，既可以用来做分类也可以用来做回归；</li><li><strong>可用于数值型数据和离散型数据</strong>；</li><li>训练时间复杂度为O(n)；无数据输入假定；</li><li>对异常值不敏感</li></ul><h2 id="算法缺点">算法缺点</h2><ul><li>计算复杂性高；空间复杂性高；</li><li>样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）；</li><li>一般数值很大的时候不用这个，计算量太大。但是单个样本又不能太少，否则容易发生误分。</li><li>最大的缺点是无法给出数据的内在含义。</li></ul><h2 id="sklearn实现k近邻算法简介">Sklearn实现k近邻算法简介</h2><p>链接: <span class="exturl" data-url="aHR0cHM6Ly9zY2lraXQtbGVhbi5vcmcvc3RhYmxlL21vZHVsZXMvZ2VuZXJhdGVkL3NrbGVhbi5uZWlnaGJvcnMuS05laWdoYm9yc0NsYXNzaWZpZXIuaHRtbA==" title="https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html">官方文档<i class="fa fa-external-link"></i></span>.</p><table><colgroup><col style="width: 40%"><col style="width: 60%"></colgroup><thead><tr class="header"><th>Method</th><th>Describe</th></tr></thead><tbody><tr class="odd"><td>fit(X, y)</td><td>Fit the model using X as training data and y as target values</td></tr><tr class="even"><td>get_params([deep])</td><td>Get parameters for this estimator.</td></tr><tr class="odd"><td>kneighbors([X, n_neighbors, return_distance])</td><td>Finds the K-neighbors of a point.</td></tr><tr class="even"><td>kneighbors_graph([X, n_neighbors, mode])</td><td>Computes the (weighted) graph of k-Neighbors for points in X</td></tr><tr class="odd"><td>predict(X)</td><td>Predict the class labels for the provided data</td></tr><tr class="even"><td>predict_proba(X)</td><td>Return probability estimates for the test data X.</td></tr><tr class="odd"><td>score(X, y[, sample_weight])</td><td>Returns the mean accuracy on the given test data and labels.</td></tr><tr class="even"><td>set_params(**params)</td><td>Set the parameters of this estimator.</td></tr></tbody></table><p><strong>KNneighborsClassifier参数说明：</strong></p><ul><li><strong>n_neighbors：</strong> 默认为5，就是k-NN的k的值，选取最近的k个点。</li><li><strong>weights：</strong> 默认是uniform，参数可以是uniform、distance，也可以是用户自己定义的函数。uniform是均等的权重，就说所有的邻近点的权重都是相等的。distance是不均等的权重，距离近的点比距离远的点的影响大。用户自定义的函数，接收距离的数组，返回一组维数相同的权重。</li><li><strong>algorithm：</strong> 快速k近邻搜索算法，默认参数为auto，可以理解为算法自己决定合适的搜索算法。除此之外，用户也可以自己指定搜索算法ball_tree、kd_tree、brute方法进行搜索，brute是蛮力搜索，也就是线性扫描，当训练集很大时，计算非常耗时。kd_tree，构造kd树存储数据以便对其进行快速检索的树形数据结构，kd树也就是数据结构中的二叉树。以中值切分构造的树，每个结点是一个超矩形，在维数小于20时效率高。ball tree是为了克服kd树高纬失效而发明的，其构造过程是以质心C和半径r分割样本空间，每个节点是一个超球体。</li><li><strong>leaf_size：</strong> 默认是30，这个是构造的kd树和ball树的大小。这个值的设置会影响树构建的速度和搜索速度，同样也影响着存储树所需的内存大小。需要根据问题的性质选择最优的大小。</li><li><strong>metric：</strong> 用于距离度量，默认度量是minkowski，也就是p=2的欧氏距离(欧几里德度量)。</li><li><strong>p：</strong> 距离度量公式。在上小结，我们使用欧氏距离公式进行距离度量。除此之外，还有其他的度量方法，例如曼哈顿距离。这个参数默认为2，也就是默认使用欧式距离公式进行距离度量。也可以设置为1，使用曼哈顿距离公式进行距离度量。</li><li><strong>metric_params：</strong> 距离公式的其他关键参数，这个可以不管，使用默认的None即可。</li><li><strong>n_jobs：</strong> 并行处理设置。默认为1，临近点搜索并行工作数。如果为-1，那么CPU的所有cores都用于并行工作。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;k近邻法是一种基本分类与回归方法。但个人并不把它列入到机器学习中的学习算法，它本身并没有对数据进行理论建模的过程，而是根据现有的数据在n维空间的分布，来确定预测点的归属。这就好比，在现实世界的维度中，经常游走于男厕所的我们归为男性，而经常在女厕所出没的人我们归为女性或者是变态。&lt;/blockquote&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://shaye-man.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://shaye-man.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法" scheme="https://shaye-man.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
